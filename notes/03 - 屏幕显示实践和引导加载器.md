# 03 - 屏幕显示实践和引导加载器

## 一、核心目标
1. 掌握**QEMU监视器**的调试方法，排查引导加载器与内核的运行问题。
2. 开发简单**操作系统内核**（ELF格式），实现死循环+`hlt`指令节能逻辑。
3. 构建**引导加载器**，完成内核文件读取、内存分配、引导服务停止、内核启动的全流程。
4. 实现屏幕像素绘制（分别从引导加载器和内核端），理解帧缓冲区（Frame Buffer）原理。
5. 添加**错误处理机制**，确保引导过程稳定，掌握指针与汇编语言的底层关联。

## 二、关键技术基础
### 1. QEMU监视器（底层开发核心调试工具）
#### （1）核心用途
- 查看CPU寄存器状态、内存内容，定位内核启动失败、内存损坏等底层问题（真机无法实现）。
- 适用于验证内核是否进入死循环、指令是否正确执行等场景。

#### （2）常用命令
| 命令                | 功能                                  | 示例与说明                          |
|---------------------|---------------------------------------|-----------------------------------|
| `info registers`    | 显示CPU所有寄存器当前值               | 重点关注`RIP`（下一条要执行的指令地址）、`RAX`等通用寄存器 |
| `x /fmt addr`       | 查看指定地址的内存内容                | `x /4xb 0x101000`（以16进制、4个字节、字节单位显示0x101000地址内容）；`x /2i 0x101000`（显示2条汇编指令） |
| 提示符 `(qemu)`     | 监视器交互入口                        | 启动QEMU后，在执行`run_qemu.sh`的终端中直接输入命令 |

#### （3）调试场景示例
- 验证内核是否进入死循环：多次执行`info registers`，若`RIP`值不变，说明CPU停止执行新指令。
- 检查`hlt`指令：通过`x /2i RIP值`查看指令，若存在`hlt`（CPU暂停指令），确认内核正常运行。

### 2. CPU寄存器（x86-64架构）
#### （1）通用寄存器（16个）
- 核心寄存器：`RAX`、`RBX`、`RCX`、`RDX`、`RBP`、`RSI`、`RDI`、`RSP`、`R8-R15`。
- 特性：64位寄存器可拆分使用（如`RAX`的低16位为`AX`，低8位为`AL`），适配不同长度数据（8位/16位/32位/64位）。
- 指令示例：`add rax, rbx`（将`RBX`的值加到`RAX`中，对应C++的`rax += rbx`）。

#### （2）专用寄存器（开发关键）
| 寄存器   | 功能                                  | 调试/开发意义                          |
|----------|---------------------------------------|-----------------------------------|
| `RIP`    | 存储下一条要执行的指令地址            | 定位程序执行位置，判断是否跳转到错误地址 |
| `RFLAGS` | 存储指令执行结果标志（如零标志`ZF`）  | 支持条件跳转（如`jnz`：ZF=0时跳转）    |
| `CR0`    | 存储CPU核心设置（如保护模式`PE`位）   | 启用保护模式（`PE=1`）、分页机制（`PG=1`）需修改该寄存器 |

### 3. ELF文件结构（内核文件格式）
#### （1）核心特性
- 类型：`EXEC`（可执行文件），64位ELF格式（`Class: ELF64`）。
- 入口地址：内核启动时的第一个指令地址，通过`readelf -h kernel.elf`查看（示例：`0x101000`）。
- 地址偏移：ELF文件头的第24字节存储入口地址（64位ELF），引导加载器通过`kernel_base_addr + 24`获取该地址。

#### （2）内核编译链接关键选项
| 工具   | 选项                                  | 含义                                  |
|--------|---------------------------------------|---------------------------------------|
| `clang++` | `--target=x86_64-elf`                 | 生成x86_64架构的ELF格式文件           |
|        | `-ffreestanding`                      | 编译为独立环境（无操作系统支持）       |
|        | `-mno-red-zone`                       | 禁用红区（避免中断破坏栈数据）         |
|        | `-fno-exceptions`/`-fno-rtti`         | 禁用C++异常和动态类型信息（精简内核） |
| `ld.lld` | `--entry KernelMain`                  | 指定内核入口函数为`KernelMain`        |
|        | `--image-base 0x100000`               | 内核加载到内存的基地址（需与引导加载器分配地址一致） |
|        | `--static`                            | 静态链接（内核无外部依赖）            |

### 4. 帧缓冲区（Frame Buffer）与GOP协议
#### （1）核心概念
- 帧缓冲区：一段连续的内存区域，每个字节/像素对应显示器上的一个像素点，写入数值即修改像素颜色。
- GOP（Graphics Output Protocol）：UEFI提供的图形输出协议，用于获取帧缓冲区信息（地址、分辨率、像素格式）。

#### （2）关键参数（通过GOP获取）
| 参数                                  | 含义                                  | 对应GOP字段                          |
|---------------------------------------|---------------------------------------|-----------------------------------|
| 帧缓冲区基地址                        | 内存起始地址（如`0x80000000`）        | `gop->Mode->FrameBufferBase`       |
| 帧缓冲区大小                          | 总字节数（分辨率×像素字节数）         | `gop->Mode->FrameBufferSize`       |
| 分辨率                                | 屏幕宽×高（如`1024x768`）             | `gop->Mode->Info->HorizontalResolution/VerticalResolution` |
| 像素格式                              | RGB排列顺序（如`BGR888`）             | `gop->Mode->Info->PixelFormat`     |

### 5. 指针进阶与类型转换
#### （1）指针与汇编语言关联
- 指针本质：存储变量内存地址的64位整数（x86-64架构），汇编中通过`mov`指令读写指针指向的内存。
- 示例（C++→汇编）：
  ```c++
  int i = 42; int* p = &i; int r1 = *p;
  ```
  对应汇编：
  ```asm
  mov dword ptr [rbp-4], 42    ; i=42（rbp-4为i的地址）
  lea rax, [rbp-4]              ; rax = &i
  mov qword ptr [rbp-16], rax   ; p = &i（rbp-16为p的地址）
  mov rax, qword ptr [rbp-16]   ; rax = p
  mov ecx, dword ptr [rax]      ; ecx = *p（r1=ecx）
  ```

#### （2）类型转换关键原则
- 整数→指针：如`(void*)0x100000`，将整数地址转换为指针，需确保地址对应内存区域合法。
- 指针→结构体指针：如`(EFI_FILE_INFO*)file_info_buffer`，需保证缓冲区地址满足结构体对齐要求（可通过`alignas`关键字指定对齐）。
- C++专用转换：`reinterpret_cast`（用于指针与整数互转，如`reinterpret_cast<uint8_t*>(frame_buffer_base)`）。

### 6. 错误处理核心原则
- 目标：避免程序因内存分配失败、文件读取失败等异常崩溃，尤其适用于操作系统这类需稳定运行的程序。
- 关键操作：
  - 检查返回值：UEFI函数返回`EFI_STATUS`类型，通过`EFI_ERROR(status)`判断是否出错。
  - 错误输出：使用`Print(L"failed: %r", status)`（`%r`专门格式化`EFI_STATUS`错误信息）。
  - 紧急停止：出错后调用`Halt()`函数（死循环+`hlt`指令），避免程序继续执行导致未知问题。

## 三、核心实践操作
### 实践1：创建第一个内核（osbook_day03a）
#### （1）内核源码（main.cpp）
```c++
extern "C" void KernelMain() {
    while (1) __asm__("hlt"); // 死循环+CPU暂停，避免占用100%算力
}
```
- 关键说明：
  - `extern "C"`：禁用C++名称修饰（name mangling），确保引导加载器能找到`KernelMain`入口（C++编译后函数名会变为`_Z10KernelMainv`，C风格为`KernelMain`）。
  - `__asm__("hlt")`：嵌入汇编指令，CPU进入暂停状态，中断触发时恢复运行。

#### （2）编译链接命令
```bash
# 编译（生成main.o对象文件）
clang++ -O2 -Wall -g --target=x86_64-elf -ffreestanding -mno-red-zone \
  -fno-exceptions -fno-rtti -std=c++17 -c main.cpp
# 链接（生成kernel.elf可执行文件）
ld.lld --entry KernelMain -z norelro --image-base 0x100000 --static \
  -o kernel.elf main.o
```

### 实践2：开发引导加载器（加载内核）
#### （1）核心流程
1. 打开内核文件：通过UEFI文件协议打开`kernel.elf`。
2. 获取文件大小：读取`EFI_FILE_INFO`结构体的`FileSize`字段。
3. 分配内存：在`0x100000`地址（与内核基地址一致）分配足够内存。
4. 加载内核：将`kernel.elf`读取到分配的内存中。
5. 停止引导服务：调用`gBS->ExitBootServices()`，释放UEFI资源（之后无法使用UEFI功能）。
6. 启动内核：通过ELF文件入口地址调用`KernelMain`。

#### （2）关键代码片段
##### ① 打开内核文件并获取大小
```c
EFI_FILE_PROTOCOL* kernel_file;
// 打开kernel.elf（只读模式）
root_dir->Open(root_dir, &kernel_file, L"\\kernel.elf", EFI_FILE_MODE_READ, 0);

// 读取文件信息（FileSize）
UINTN file_info_size = sizeof(EFI_FILE_INFO) + sizeof(CHAR16)*12;
UINT8 file_info_buffer[file_info_size];
kernel_file->GetInfo(kernel_file, &gEfiFileInfoGuid, &file_info_size, file_info_buffer);
EFI_FILE_INFO* file_info = (EFI_FILE_INFO*)file_info_buffer;
UINTN kernel_file_size = file_info->FileSize;
```

##### ② 分配内存并加载内核
```c
EFI_PHYSICAL_ADDRESS kernel_base_addr = 0x100000; // 内核基地址
// 计算所需页数（4KiB=0x1000/页）
UINTN pages = (kernel_file_size + 0xfff) / 0x1000;
// 分配内存（指定地址分配，类型为EfiLoaderData）
gBS->AllocatePages(AllocateAddress, EfiLoaderData, pages, &kernel_base_addr);
// 读取内核文件到内存
kernel_file->Read(kernel_file, &kernel_file_size, (VOID*)kernel_base_addr);
```

##### ③ 停止引导服务（需重试机制）
```c
EFI_STATUS status;
struct MemoryMap memmap;
// 第一次获取内存映射（用于ExitBootServices）
GetMemoryMap(&memmap);
status = gBS->ExitBootServices(image_handle, memmap.map_key);
if (EFI_ERROR(status)) {
    // 内存映射可能变化，重新获取后重试
    GetMemoryMap(&memmap);
    status = gBS->ExitBootServices(image_handle, memmap.map_key);
    if (EFI_ERROR(status)) {
        Print(L"Could not exit boot service: %r\n", status);
        Halt();
    }
}
```

##### ④ 启动内核（获取ELF入口地址）
```c
// ELF文件头第24字节存储入口地址（64位ELF）
UINT64 entry_addr = *(UINT64*)(kernel_base_addr + 24);
// 定义入口函数类型（无参数、无返回值）
typedef void EntryPointType(void);
EntryPointType* entry_point = (EntryPointType*)entry_addr;
entry_point(); // 调用KernelMain
```

#### （3）构建与运行
```bash
# 切换源码版本
cd $HOME/workspace/mikanos && git checkout osbook_day03a
# 构建引导加载器
cd $HOME/edk2 && source edksetup.sh && build
# 启动QEMU（加载引导加载器和内核）
$HOME/osbook/devenv/run_qemu.sh Build/MikanLoaderX64/DEBUG_CLANG38/X64/Loader.efi \
  $HOME/workspace/mikanos/kernel/kernel.elf
```

### 实践3：屏幕像素绘制（引导加载器端，osbook_day03b）
#### （1）核心逻辑
1. 通过UEFI的GOP协议获取帧缓冲区信息（地址、大小）。
2. 直接向帧缓冲区写入数值，修改像素颜色（如写入255=0xff，像素显示白色）。

#### （2）关键代码
```c
// 获取GOP协议（图形输出协议）
EFI_GRAPHICS_OUTPUT_PROTOCOL* gop;
OpenGOP(image_handle, &gop);

// 打印帧缓冲区信息
Print(L"Resolution: %ux%u\n", gop->Mode->Info->HorizontalResolution, 
      gop->Mode->Info->VerticalResolution);
Print(L"Frame Buffer: 0x%0lx\n", gop->Mode->FrameBufferBase);

// 向帧缓冲区写入白色（所有像素设为255）
UINT8* frame_buffer = (UINT8*)gop->Mode->FrameBufferBase;
for (UINTN i=0; i<gop->Mode->FrameBufferSize; ++i) {
    frame_buffer[i] = 255;
}
```

### 实践4：内核端像素绘制（osbook_day03c）
#### （1）核心改进
- 引导加载器→内核传递帧缓冲区信息：通过`KernelMain`参数传递基地址和大小。
- 内核绘制彩色图案：根据像素索引动态修改颜色（如`i%256`，实现渐变效果）。

#### （2）内核源码（main.cpp）
```c++
#include <cstdint>

// 接收引导加载器传递的帧缓冲区信息
extern "C" void KernelMain(uint64_t frame_buffer_base, uint64_t frame_buffer_size) {
    uint8_t* frame_buffer = reinterpret_cast<uint8_t*>(frame_buffer_base);
    // 绘制渐变图案（每个像素颜色=索引%256）
    for (uint64_t i=0; i<frame_buffer_size; ++i) {
        frame_buffer[i] = i % 256;
    }
    while (1) __asm__("hlt");
}
```

#### （3）引导加载器参数传递代码
```c
// 定义带参数的入口函数类型（两个uint64_t参数）
typedef void EntryPointType(UINT64, UINT64);
EntryPointType* entry_point = (EntryPointType*)entry_addr;
// 传递帧缓冲区基地址和大小
entry_point(gop->Mode->FrameBufferBase, gop->Mode->FrameBufferSize);
```

### 实践5：添加错误处理（osbook_day03d）
#### （1）内存分配错误处理示例
```c
EFI_PHYSICAL_ADDRESS kernel_base_addr = 0x100000;
EFI_STATUS status = gBS->AllocatePages(
    AllocateAddress, EfiLoaderData, pages, &kernel_base_addr
);
if (EFI_ERROR(status)) {
    Print(L"failed to allocate pages: %r\n", status);
    Halt(); // 死循环+hlt，停止程序
}
```

#### （2）Halt函数实现
```c
void Halt(void) {
    while (1) __asm__("hlt"); // 避免CPU空转，等待中断（无中断则持续暂停）
}
```

## 四、关键工具与命令汇总
| 工具/命令组合                          | 用途                                  | 场景                          |
|---------------------------------------|---------------------------------------|-------------------------------|
| `readelf -h kernel.elf`               | 查看ELF文件头（入口地址、架构等）     | 验证内核编译是否正确          |
| `clang++ $CPPFLAGS ... -c main.cpp`   | 编译内核（使用buildenv.sh配置的环境变量） | 内核源码编译                  |
| `ld.lld $LDFLAGS ... -o kernel.elf`   | 链接内核（静态链接，指定入口和基地址） | 生成可执行内核文件            |
| `source $HOME/osbook/devenv/buildenv.sh` | 加载内核编译所需环境变量（如CPPFLAGS） | 编译前初始化环境              |
| `$HOME/osbook/devenv/run_qemu.sh 引导器.efi 内核.elf` | 启动QEMU并加载引导器和内核 | 测试内核启动和像素绘制        |

## 五、注意事项与学习建议
### 1. 常见问题排查
- 内核启动失败（`RIP`地址异常）：检查`kernel_base_addr`是否为`0x100000`，与链接器`--image-base`一致。
- 帧缓冲区绘制无效果：确认`frame_buffer_base`地址正确，像素格式与写入数值匹配（如`BGR888`需写入3字节/像素）。
- 编译报错（找不到`<cstdint>`）：先执行`source buildenv.sh`，加载`CPPFLAGS`中的头文件路径。

### 2. 核心知识点延伸
- 红区（Red Zone）：RSP下方128字节区域，中断处理程序不得修改，内核编译需禁用（`-mno-red-zone`），避免数据破坏。
- 内存对齐：结构体指针转换时需满足对齐要求（如`EFI_FILE_INFO`需N字节对齐），可通过`alignas(alignof(类型))`指定。
- UEFI引导服务与运行时服务：`gBS`（引导服务）在`ExitBootServices`后失效，`gRT`（运行时服务）可在操作系统运行时使用。

### 3. 学习建议
- 手动调试：使用QEMU监视器跟踪`RIP`变化，对比汇编指令与C++代码，理解指针的底层实现。
- 拓展实践：修改内核绘制逻辑（如绘制矩形、文字），加深对帧缓冲区的理解。
- 研读ELF文件：通过`readelf -l kernel.elf`查看程序段分布，理解内核在内存中的布局。